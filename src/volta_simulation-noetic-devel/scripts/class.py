#!/usr/bin/env python3
import sys
from math import sqrt
import rospy
import math
import numpy as np
from geometry_msgs.msg import Twist, Pose2D, Point, PoseStamped
from tf.transformations import euler_from_quaternion
from gazebo_msgs.msg import ModelStates

class PotentialFieldComputer:
    def __init__(self, q_repel, q_attract, dist_threshold, robot_name):
        """

        :param q_repel: coefficient of repelling force between vehicle and obstacles
        :param q_attract: coefficient of attraction force between vehicle and target point
        :param dist_threshold: sphere of influence of individual obstacle point. Repelling force is zero if the distance
        to the point is more than dist_threshold
        """
        self.q_repel = q_repel
        self.q_attract = q_attract
        self.dist_threshold = dist_threshold
        self.goal_x, self.goal_y, self.goal_theta = 0,0,0
        self.no_of_robots = 4
        self.robot_name = robot_name
        self.prev_time = 0
        self.goal_sub = rospy.Subscriber("/move_base_simple/goal", PoseStamped, self.goal_recieved, queue_size=1)

    def compute_trajectory(self, point_cloud, vehicle_coord, target_coord, speed, dt=0.1, n_points=20):
        """
        Computes a local trajectory by simulating a particle motion inside the potential field generated by target point
        and points from obstacle point cloud

        :param point_cloud: np.array(shape=(N, 2)) containing the point cloud
        :param vehicle_coord: np.array(shape=(2)) current coordinate of vehicle.
        :param target_coord: np.array(shape=(2)) coordinate of the target point
        :param speed: speed of particle motion
        :param dt: time step of motion equation solver
        :param n_points: number of points in motion equation solution
        :return: np.array(shape=(n_points, 2)) local trajectory
        """
        # trajectory = np.zeros(shape=(n_points, 2))
        # trajectory[0] = vehicle_coord
        # for i in range(1, n_points):
        #     if len(point_cloud) == 0:
        #         repelling_force = np.zeros(2)
        #     else:
        #         diff = point_cloud - vehicle_coord.reshape(1, 3)
        #         dist = np.linalg.norm(diff, axis=1, keepdims=True)
        #         repel_directions = -diff / dist

        #         distance_component = (1 / dist - 1 / self.dist_threshold)

        #         nullifier = np.ones_like(diff)
        #         nullifier[dist.reshape(-1) > self.dist_threshold, :] = np.zeros(2)

        #         repelling_force = np.sum(repel_directions * self.q_repel * nullifier * distance_component, axis=0)

        #     attraction_force = 2 * self.q_attract * (target_coord - vehicle_coord) / np.linalg.norm(target_coord - vehicle_coord)
        #     print("distance between target and vehicle = ",np.linalg.norm(target_coord - vehicle_coord))
        #     force = attraction_force + repelling_force
        #     velocity = speed * force / np.linalg.norm(force)
        #     vehicle_coord = vehicle_coord + velocity * dt

        #     trajectory[i] = vehicle_coord
        
        if len(point_cloud) == 0:
            repelling_force = np.zeros(2)
        else:
            diff = point_cloud - vehicle_coord.reshape(1, 2)
            dist = np.linalg.norm(diff, axis=1, keepdims=True)
            repel_directions = -diff / dist

            distance_component = (1 / dist - 1 / self.dist_threshold)

            nullifier = np.ones_like(diff)
            nullifier[dist.reshape(-1) > self.dist_threshold, :] = np.zeros(2)

            repelling_force = np.sum(repel_directions * self.q_repel * nullifier * distance_component, axis=0)

        attraction_force = 2 * self.q_attract * (target_coord - vehicle_coord) / np.linalg.norm(target_coord - vehicle_coord)
        print("distance between target and vehicle = ",np.linalg.norm(target_coord - vehicle_coord))
        force = attraction_force + repelling_force
        velocity = speed * force / np.linalg.norm(force)
        
        return velocity
        # return trajectory.copy()

    def newModel(self,msg):
        list_of_obstacle_coord = []
        ego_coord,ego_theta = [],0
        
        myargv = rospy.myargv(argv=sys.argv)
        self.robot_name = myargv[1]
        print("/"+self.robot_name+"/cmd_vel")
        cmd_vel = rospy.Publisher("/"+self.robot_name+"/cmd_vel", Twist, queue_size=1)

        for robot in range(1,len(msg.name)):
            if(msg.name[robot] != self.robot_name):
                list_of_obstacle_coord.append( [msg.pose[robot].position.x , msg.pose[robot].position.y] )
                print(f"Other robot : "+msg.name[robot] + " with coordinates = ({},{})".format(msg.pose[robot].position.x,msg.pose[robot].position.y))
            else:
                ego_coord.append( [msg.pose[robot].position.x , msg.pose[robot].position.y] )
                ego_theta = msg.pose[robot].orientation.z
                print(f"Ego robot : "+msg.name[robot] + " with coordinates = ({},{}) at time = {}".format(msg.pose[robot].position.x,msg.pose[robot].position.y,rospy.Time.now().to_sec()))

        obstacle_coord = np.array(list_of_obstacle_coord)
        ego_coord = np.array(ego_coord)
        velocity = self.compute_trajectory(obstacle_coord,ego_coord,np.array([self.goal_x,self.goal_y]), speed=0.1)
        vel_cmd = Twist()
        
        if math.sqrt( (ego_coord[0][0]-self.goal_x)**2 + (ego_coord[0][1]-self.goal_y)**2 ) < 0.75:
            vel_cmd.linear.x,vel_cmd.angular.z = 0.0,0.0
            cmd_vel.publish(vel_cmd)
            rospy.sleep(60.0)
        else:
            vel_cmd.linear.x =  math.sqrt(velocity[0][0]**2 +  velocity[0][1]**2)
            kp = 0.005
            try:
                vel_cmd.angular.z = ( ( math.atan2(velocity[0][1],velocity[0][0]) - ego_theta ) * kp) / (rospy.Time.now().to_sec() - self.prev_time)
            except ZeroDivisionError:
                vel_cmd.linear.x,vel_cmd.angular.z = 0.0,0.0
        self.prev_time = rospy.Time.now().to_sec()
        print(f""+"vel_commands = ({},{})".format(vel_cmd.linear.x,vel_cmd.angular.z))
        cmd_vel.publish(vel_cmd)

    def goal_recieved(self,msg):
        self.goal_x, self.goal_y, self.goal_theta = msg.pose.position.x,msg.pose.position.y,msg.pose.orientation.z
        print(f""+"(goal_x,goal_y) = ({},{})".format(self.goal_x,self.goal_y))
        sub = rospy.Subscriber("/gazebo/model_states",ModelStates,self.newModel,queue_size=1)
    
        
if __name__ == '__main__':
    print('Running')
    rospy.init_node("apf_multi_robot_planner")
    myargv = rospy.myargv(argv=sys.argv)
    robot_name = myargv[1]
    rate = rospy.Rate(4)
    apf_planner = PotentialFieldComputer(q_repel=25, q_attract=10, dist_threshold=5,robot_name=robot_name)
    while not rospy.is_shutdown():
        k=0